# 小さなCLを作るためのガイド

## なぜ小さなCLを書くのか？ {#why}

小さくシンプルなCLは以下のような利点があります：

- **早くレビューされる。** レビュアーにとって、一つの大きなCLに30分を割くより、数回に分けて5分ずつ小さなCLをレビューする方が簡単です。
- **より詳細にレビューされる。** 大きな変更では、レビュアーと著者が詳細なコメントのやり取りによって疲れ、重要な点が見落とされたり省略されたりすることがあります。
- **バグを導入する可能性が低い。** 変更が少ないため、CLの影響について効率的に推論し、バグが導入されたかどうかを確認することが容易です。
- **却下された場合の無駄な作業が少ない。** 大きなCLを書いてからレビュアーが全体的な方向性が間違っていると言った場合、多くの作業が無駄になります。
- **マージが容易。** 大きなCLの作業には時間がかかるため、頻繁にマージを行う必要があり、多くの意見の対立が生じる可能性があります。
- **設計が容易。** 小さな変更の設計とコード品質を磨く方が、大きな変更のすべての詳細を洗練するよりもはるかに容易です。
- **レビューでのブロッキングが少ない。** 全体的な変更の自己完結した部分を送信することで、現在のCLがレビューされている間にコーディングを続けることができます。
- **ロールバックがシンプル。** 大きなCLは、初回のCL提出とロールバックCLの間に更新されるファイルに触れる可能性が高く、ロールバックを複雑にする可能性があります（中間のCLもおそらくロールバックする必要があります）。

注意してください。**レビュアーは、それが大きすぎるという単一の理由であなたの変更を即座に却下する裁量権を持っています。** 通常、貢献に感謝しつつ、何らかの方法でそれを一連の小さな変更にするように依頼します。既に書き上げた後で変更を分割する作業は大変であり、レビュアーが大きな変更を受け入れるべき理由について多くの時間を議論する必要があるかもしれません。最初から小さなCLを書く方が簡単です。

## 小さいとは何か？ {#what_is_small}

一般的に、CLの適切なサイズは**一つの自己完結した変更**です。これは以下を意味します：

- CLは、**一つのことにだけ対処する**最小限の変更を行います。これは通常、一度に一つの機能の一部分であり、全体ではありません。一般的には、大きすぎるCLを書くよりも、小さすぎるCLを書く方が良いです。許容可能なサイズは何かをレビュアーと共に見つけ出してください。
- CLは、関連するテストコードを[含むべきです](#test_code)。
- レビュアーがCLについて理解する必要があるすべてのこと（将来の開発を除く）は、CL内、CLの説明、既存のコードベース、またはすでにレビューされたCLのいずれかに含まれています。
- CLがチェックインされた後も、システムはそのユーザーと開発者にとってうまく機能します。
- CLは、その意味が理解しにくいほど小さくありません。新しいAPIを追加する場合、そのAPIの使用例も同じCLに含めると、レビュアーがAPIの使用方法をよりよく理解できます。これにより、未使用のAPIがチェックインされるのを防ぎます。

「大きすぎる」とはどれほどかについての硬直的なルールはありません。通常、CLのサイズとして100行は妥当であり、1000行は大きすぎるとされますが、これはレビュアーの判断によります。変更が広がるファイル数もその「サイズ」に影響します。一つのファイルでの200行の変更は許容されるかもしれませんが、50ファイルに広がると通常は大きすぎます。

あなたがコードを書き始めた瞬間からそのコードに密接に関与している一方で、レビュアーは多くの場合、そのコードについての文脈を持っていません。あなたが許容でき

るサイズのCLが、レビュアーにとっては圧倒的に感じる場合があります。疑問の場合は、あなたが書く必要があると思っているよりも小さいCLを書いてください。レビュアーは、小さすぎるCLを受け取ることについてほとんど不満を言いません。

## 大きなCLが許される場合は？ {#large_okay}

大きな変更がそれほど問題ではないいくつかの状況があります：

- 一つのファイルの削除は、通常一行の変更としてカウントできます。なぜなら、それはレビュアーにとってレビューするのにそれほど時間がかからないからです。
- たまに、大きなCLが完全に信頼できる自動リファクタリングツールによって生成され、レビュアーの仕事はその変更を本当に望んでいるかどうかを確認し、言うことです。これらのCLは大きくてもよいですが、上記のいくつかの警告（例えばマージやテストなど）は依然として適用されます。

## 効率的に小さなCLを書く方法 {#efficiently}

小さなCLを書いて、次のCLを書く前にレビュアーがそれを承認するのを待つならば、多くの時間を無駄にすることになります。ですから、レビューを待っている間に作業を停止させない何らかの方法を見つけたいと思うでしょう。これには、同時に複数のプロジェクトに取り組む、すぐに利用可能であることに同意したレビュアーを見つける、対面でのレビューを行う、ペアプログラミングをする、または作業を即座に続けることができるようにCLを分割する、などが考えられます。

## CLを分割する {#splitting}

お互いに依存関係がある複数のCLを持つ作業を開始する際、コーディングに取り掛かる前に、それらのCLをどのように分割し、整理するかを高レベルで考えることが多くの場合有用です。

これは著者としてのあなたがCLを管理し、整理するのを容易にするだけでなく、コードレビュアーにとっても事を容易にするため、コードレビューがより効率的に行えます。

異なるCLに作業を分割するためのいくつかの戦略を以下に示します。

### 互いに積み重ねて複数の変更を行う {#stacking}

CLをブロックすることなく分割する一つの方法は、一つの小さなCLを書き、それをレビューに送った後、すぐにそのCLを**基にした**別のCLを書き始めることです。ほとんどのバージョン管理システムでは、何らかの形でこれを可能にしています。

### ファイルによる分割 {#splitting-files}

CLを分割するもう一つの方法は、異なるレビュアーが必要だがそれ以外は自己完結した変更によるファイルのグループ分けです。

例えば、プロトコルバッファに対する変更のための一つのCLと、そのプロトを使用するコードに対する変更のための別のCLを送信します。プロトのCLはコードのCLの前に提出する必要がありますが、両方とも同時にレビューされることができます。これを行う場合、他のCLについて両方のセットのレビュアーに通知するとよいでしょう。そうすることで、彼らはあなたの変更に対する文脈を持つことができます。

別の例：コードの変更のための一つのCLと、そのコードを使用する設定または実験のための別のCLを送信します。これも必要に応じてロールバックするのが容易です。設定/実験ファイルはコードの変更よりも高速にプロダクションにプッシュされることがよくあります。

### 横に分割する {#splitting-horizontally}

技術スタックの各層間の変更を隔離するために共有コードやスタブを作成することを検討してください。これは開発を促進するだけでなく、層間の抽象化を促進します。

例：計算機アプリを作成し、クライアント、API、サービス、データモデルの各層を持っています。共有のプロト署名は、サービス層とデータモデル層を互いに抽象化することができます。同様に、APIスタブは、クライアントコードの実装とサービスコードを分け、それらを独立して前進

させることができます。このような考え方は、より粒度の細かい関数やクラスレベルの抽象にも適用できます。

### 縦に分割する {#splitting-vertically}

層状の、水平なアプローチに直交して、コードをより小さな、フルスタックの、垂直な機能に分解することができます。これらの各機能は、独立した並列実装のトラックとなることができます。これにより、一部のトラックがレビューやフィードバックを待っている間に、他のトラックが前進することができます。

[横に分割する](#splitting-horizontally)からの計算機の例に戻ります。これから乗算と除算といった新しい演算子をサポートしたいと考えています。これを分割する一つの方法は、乗算と除算を別々の垂直またはサブ機能として実装することです。それらは共有のボタンのスタイリングや共有のバリデーションロジックなど、いくつかの重複があるかもしれません。

### 横にも縦にも分割する {#splitting-grid}

これをさらに一歩進めて、これらのアプローチを組み合わせ、各セルが独自のスタンドアローンなCLであるような実装計画をこのようにチャート化することができます。モデル（一番下）から始めてクライアントに至るまで：

| 層     | 機能：乗算               | 機能：除算                      |
| ------ | ------------------------ | -------------------------------- |
| クライアント | ボタンを追加            | ボタンを追加                    |
| API    | エンドポイントを追加      | エンドポイントを追加            |
| サービス | 変換を実装              | 乗算とロジックを共有            |
| モデル  | プロトの定義を追加        | プロトの定義を追加              |

## リファクタリングを別にする {#refactoring}

一般的に、リファクタリングは機能の変更やバグ修正から別のCLで行う方が良いです。例えば、クラスを移動して名前を変更する作業は、そのクラスに関するバグを修正する作業とは別のCLで行うべきです。各CLによって導入された変更を理解することが、それらが別れている場合にはるかに容易です。

ローカル変数の名前を修正するような小さなクリーンアップは、機能の変更やバグ修正のCL内に含めることもできます。リファクタリングが大きすぎてレビューが難しくなる場合は、開発者とレビュアーが判断するときに、そのリファクタリングを現在のCLに含めるべきかどうかを決定する必要があります。

## 関連するテストコードを同じCLに保持する {#test_code}

CLは関連するテストコードを含むべきです。[小ささ](#what_is_small)はここでは、CLが焦点を絞っているべきであり、行数に基づく単純な関数ではない、という概念的なアイデアに言及しています。

新しいロジックを追加するか変更するCLは、新しい挙動に対する新規または更新されたテストに伴うべきです。純粋なリファクタリングのCL（挙動を変更する意図がない）もテストでカバーされるべきです。理想的には、これらのテストはすでに存在していますが、存在しない場合は追加するべきです。

*独立した*テストの変更は、最初に別のCLで行くことができます。これには以下が含まれます：

* 既存の、提出済みのコードを新しいテストで検証。
  * 重要なロジックがテストでカバーされていることを確保。
  * 影響を受けるコードに対する後続のリファクタリングに対する信頼を高める。例えば、すでにテストでカバーされていないコードをリファクタリングする場合、リファクタリングのCLを提出する*前に*テストのCLを提出することで、テストされた挙動がリファクタリング前後で変更されていないことを確認できます。
* テストコードのリファクタリング（例：ヘルパー関数を導入）。
* より大きなテストフレームワークのコードを導入（例：統合テスト）。

## ビルドを壊さない {#break}

お互いに依存する複数のCLがある場合、各CLが提出された後に全体のシステムが正常に機能し続け

るようにする必要があります。特に、あなたのCLが他の開発者に影響を与える可能性がある場合、ビルドやテストが壊れると、その影響は極めて大きくなります。

ビルドを壊さないためには、以下の手段が考えられます：

- **フラグによる制御**: 新しいコードをフラグで制御することで、デフォルトでは実行されないようにします。これにより、CLが提出された後でも既存のテストが壊れることはありません。
- **スタブとインターフェース**: 新しいコードが依存するコードをスタブやインターフェースで置き換えます。これにより、新しいコードが完全に機能する前でも、既存のコードは壊れません。
- **依存関係の逆転**: 依存関係が一方通行になるように新旧のコードを調整します。例えば、既存のコードが新しいコードを呼び出すのではなく、新しいコードが既存のコードを呼び出すようにします。
- **小さな一歩を繰り返す**: 大きな機能を小さな部分に分け、その小さな部分を独立して提出します。各部分が提出されると、システムは新しい機能に向けて小さな一歩進むだけであり、大きな変更が一度に行われることはありません。
- **テスト**: 提出前に全てのテストが通ることを確認します。これにより、提出したCLがビルドを壊す可能性が大幅に減ります。

## まとめ {#conclusion}

小さなCLは高品質なソフトウェアを効率的に作成する上で非常に有用です。これはレビュアーによる詳細なレビューを容易にし、バグの導入を防ぎます。さらに、小さなCLは却下された場合のリスクを低減し、マージの複雑さを減らします。

CLを小さく保つための具体的な戦略としては、CLを互いに積み重ねて作成する、ファイルや機能、層によってCLを分割する、リファクタリングと機能の変更を別のCLで行う、関連するテストコードを同じCLに保持する、ビルドを壊さないようにする、などがあります。

これらのガイドラインは一般的なものであり、特定のケースには必ずしも当てはまらない場合もあります。しかし、これらの原則を理解し適用することで、より効率的な開発プロセスと高品質なコードベースの両方を実現できるでしょう。