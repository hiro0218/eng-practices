# 良いCL（変更リスト）の説明を書く

CLの説明は、**何の**変更が行われ、**なぜ**行われたのかについての公的な記録です。これはバージョン管理の履歴の永続的な一部となり、年月を経てレビュアー以外の何百人もの人々によって読まれる可能性があります。

未来の開発者は、その説明に基づいてあなたのCLを検索します。将来、誰かがその関連性のかすかな記憶をもっているが、詳細は手元にない状況であなたの変更を探しているかもしれません。重要な情報がすべてコード内にあり、説明にはない場合、彼らがあなたのCLを見つけるのははるかに困難になります。

## 最初の行 {#firstline}

*   行われることの短い要約。
*   命令形の完全な文。
*   空行で続ける。

CL説明の**最初の行**は、CLによって**具体的に何が行われるか**についての短い要約であり、その後に空行が続きます。これはバージョン管理の履歴要約に表示されるため、未来のコード検索者があなたのCLやその全体の説明を読まずに、あなたのCLが実際に*何をしたのか*、また他のCLとどのように異なるのかを理解できるほど、情報提供が十分でなければなりません。つまり、最初の行は単独で存在し、読者がコード履歴をはるかに速くスキャンできるようにするべきです。

最初の行を短く、集中的に、そして的を射たものに保つように努力してください。明確性と、読者に対する有用性が最優先事項であるべきです。

慣習により、CL説明の最初の行は命令文（imperative sentence）として書かれた完全な文です。例えば、「**FizzBuzz RPCを削除し、新しいシステムで置き換える。**」と言う代わりに、「**FizzBuzz RPCを削除して、新しいシステムで置き換えます。**」と書きます。ただし、説明の残りを命令形で書く必要はありません。

## 本文は情報提供が豊富 {#informative}

[最初の行](#firstline)は短く、集中的な要約であるべきですが、説明の残りは、読者が変更リストを全体的に理解するために必要な詳細と補足情報を含むべきです。解決される問題の簡単な説明や、なぜこれが最良のアプローチであるかなどが含まれるかもしれません。アプローチに不足がある場合は、それも言及されるべきです。関連性がある場合は、バグ番号、ベンチマーク結果、設計文書へのリンクなどの背景情報を含めてください。

外部リソースへのリンクを含める場合は、アクセス制限や保存ポリシーにより、将来の読者がそれらを見ることができないかもしれないと考慮してください。可能な限り、レビュアーや未来の読者がCLを理解するための十分な文脈を提供してください。

小さなCLであっても、細部への注意が必要です。CLを文脈に置いてください。

## 悪いCLの説明 {#bad}

「バグを修正」は不十分なCLの説明です。どのバグですか？それを修正するために何をしましたか？同様に悪い説明としては以下のようなものがあります：

-   「ビルドを修正。」
-   「パッチを追加。」
-   「コードをAからBに移動。」
-   「フェーズ1。」
-   「便利な関数を追加。」
-   「奇妙なURLを削除。」

これらのいくつかは実際のCLの説明です。短いにもかかわらず、十分な有用な情報を提供していません。

## 良いCLの説明 {#good}

良い説明の例をいくつか挙げます。

### 機能の変更

例：

> rpc: RPCサーバーメッセージのフリーリストにサイズ制限をなくす。
>
> FizzBuzzのようなサーバーは非常に大きなメッセージを持っており、再利用により利益を得られます。フリーリストを大きくし、フリーリストのエントリを時間をかけてゆっくりと解放するgoroutineを追加します。これにより、アイドル状態のサーバーは最終的にすべ

てのフリーリストのエントリを解放します。

最初の数語は、CLが実際に何をするのかを説明しています。説明の残りは、解決される問題、なぜこれが良い解決策であるか、および具体的な実装についての少し詳しい情報を話しています。

### リファクタリング

例：

> TimeKeeperを使用してタスクを構築し、そのTimeStrおよびNowメソッドを使用する。
>
> タスクにNowメソッドを追加し、borglet()のgetterメソッドを削除します（これはOOMCandidateがborgletのNowメソッドを呼び出すためにのみ使用されていました）。これにより、TimeKeeperに委譲するBorglet上のメソッドが置き換えられます。
>
> タスクがNowを提供することで、Borgletへの依存を排除する一歩となります。最終的には、タスクからNowを取得する依存関係を持つコラボレータは、直接TimeKeeperを使用するように変更されるべきですが、これは小規模なステップでリファクタリングを進めるための妥協です。
>
> Borglet階層のリファクタリングの長期的な目標を続けます。

最初の行は、CLが何をしているのか、これが過去とどのように異なるのかを説明しています。説明の残りは、具体的な実装、CLの文脈、解決策が理想的でない点、および可能な将来の方向性について説明しています。また、この変更が行われる*理由*も説明しています。

### 文脈が必要な小さなCL

例：

> status.py用のPython3ビルドルールを作成する。
>
> これにより、すでにPython3でこれを使用している消費者が、元のステータスビルドルールの隣にあるルールに依存することができます。これは、Python2ではなくPython3を使用できる新しい消費者に対してそれを奨励し、現在作業中の一部の自動ビルドファイルリファクタリングツールを大幅に単純化します。

最初の文は、実際に何が行われているのかを説明しています。説明の残りは、変更が行われる*理由*を説明し、レビュアーに多くの文脈を提供しています。

## タグの使用 {#tags}

タグは手動で入力されるラベルで、CLをカテゴリ分けするために使用できます。これはツールによってサポートされているか、チームの慣習によって使用される場合があります。

例：

-   "[tag]"
-   "[長いタグ]"
-   "#tag"
-   "tag:"

タグの使用はオプションです。

タグを追加する場合、それらがCL説明の[本文](#informative)にあるべきか、[最初の行](#firstline)にあるべきかを考慮してください。最初の行でのタグの使用を制限し、コンテンツを不明瞭にしないようにしてください。

タグがある場合とない場合の例：

``` {.good}
// 最初の行で短く保たれている場合、タグは大丈夫です。
[バナナ] 食べる前にバナナの皮をむく。

// タグはコンテンツにインラインできます。
#バナナを食べる前にむく。

// タグはオプションです。
バナナを食べる前にむく。

// 複数のタグも、短く保たれている場合は許容されます。
#バナナ #リンゴ: フルーツバスケットを作る。

// タグはCL説明のどこにでも行くことができます。
> フルーツバスケットを作る。
>
> #バナナ #リンゴ
```

``` {.bad}
// あまりにも多くのタグ（または長すぎるタグ）は最初の行を圧倒します。
//
// 代わりに、タグが説明の本文に移動できるか、または短縮できるかどうかを検討してください。
[バナナ皮むき工場][リンゴ摘みサービス] フルーツバスケットを作る。
```

## 生成されたCLの説明

一部のCLはツールによって生成されます。可能な限り、それらの説明もここでのアドバイスに従うべきです。つまり、最初の行は短く、集中して、単独で存在するべきであり、CL説明の本文は、レビュアーや未来のコード検索者が各CLの効果を理解するのに役立つ情報提供が豊富な詳細を含むべきです。

## CLを提出する前に説明を確認する

CLはレビュー中に大きな変更を受ける可能性があります。CLの説明がまだCLが行っていることを反映しているかどうかを確認することは、価値があります。

次へ：[小さなCL](small-cls.md)